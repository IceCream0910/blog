import { Viewport } from "pixi-viewport";
import { Container } from "pixi.js";
import { LinkWithCoords, Node, WithCoords, ZoomLevels } from "./types";
import { KnowledgeGraphDb } from "./db";
import { GraphEventEmitter } from "./graphEvents";
/**
 * Node labels renderer with Hierarchical Level of Detail (HLoD) and culling (only rendering what is currently seen by the camera)
 *
 * When `moved-end` event fires, these things can happen:
 * 1. Labels for 'big' nodes (with large children count) may be invisible if zoomed out very much
 * 2. Labels for 'small' nodes (with small children count) may be invisible if zoomed out a bit
 * 3. Labels for 'small' nodes (with small children count) may be visible if zoomed in very much
 * 4. Labels for 'big' nodes (with large children count) may be visible if zoomed in a bit
 * 5. New labels appear if the zoom level does not change and location (x,y) of camera changes
 * 6. Old labels disappear in the previous camera location if the zoom level does not change and location (x,y) of camera changes
 * 7. Some existing labels stay visible if the zoom level does not change very much and new camera location includes some part of the previous camera location
 *
 * The strategy to meet this condition:
 *
 * Every time moved-end event happens,
 * 1. See if any of the labels need to appear
 * 2. See if any of the labels need to stay visible
 * 3. See if any of the labels need to disappear
 */
export declare class ConditionalNodeLabelsRenderer<N extends WithCoords<Node>, L extends LinkWithCoords> {
    /**
     * Viewport of the application.
     */
    private viewport;
    /**
     * Container that stores all labels.
     */
    private nodeLabelsContainer;
    /**
     * This is always defined!!
     * The typing is just because of how TS works
     */
    private db;
    private visibleLabelsMap;
    private eventTarget;
    private graphEventEmitter;
    private initComplete;
    private zoomLevels?;
    constructor(viewport: Viewport, nodes: WithCoords<Node>[], links: LinkWithCoords[], graphEventEmitter: GraphEventEmitter<N, L>, 
    /**
     * Optional db instantiated from outside of the class
     */
    db?: KnowledgeGraphDb, 
    /**
     * Custom zoom levels for conditionally rendering labels at different zoom levels
     */
    zoomLevels?: ZoomLevels);
    onError(cb: VoidFunction): void;
    /**
     * IndexedDB takes some time to be initialized
     */
    onInitComplete(cb: (...params: any[]) => any): void;
    getNodeLabelsContainer(): Container;
    /**
     * Since the indexedDB query returns plain arrays containing primary keys,
     * we need to turn some of them into `Set` for operations with better time complexities
     */
    private optimizeNextLabelVisibilityInputs;
    /**
     * Categorizes labels (nodes) into
     * 1. Now visible labels: any visible labels in the current screen.
     * 2. Now appearing labels: labels that did not exist but now must appear in the current screen
     * 3. Now disappearing labels: labels that existed in the screen but now must disappear
     */
    private processPreviousAndNextLabels;
    private getVisibleNodesSet;
    private deleteDisappearingLabels;
    /**
     * @returns
     * a promise of transaction that will resolve to an array of
     * 1) the nodes that must appear now
     * 2) the nodes that must disappear now,
     *
     * and a method to `cancel` the transaction.
     */
    private calculateNextLabelVisibility;
    /**
     * make sure you still delete labels that go outside of the current screen
     * because you are moving around in a viewport
     */
    private deleteLabelsOnDragging;
    /**
     * moved-end callback of `this.viewport`
     */
    private onMovedEnd;
    /**
     * Just dump everything into the db
     */
    private initDb;
    /**
     * moved-end event includes zoom, drag, ... everything.
     */
    private initMovedEndListener;
    /**
     * Creates visual labels (texts) from the titles of nodes
     * @param nodes - nodes with titles
     */
    private createBitmapTextsAsNodeLabels;
}
