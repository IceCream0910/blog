import { NotionAPI } from 'notion-client';
import { ErrorObject } from 'serialize-error';

declare function createLogger(isVerbose: boolean): ((msg: string) => void) | null;

/**
 * https://developers.notion.com/reference/request-limits
 * Notion API has a request limit
 * also, although we are using unofficial API,
 * it's a good idea not to overload the server too much anyway
 * So use a simple request queue to control number of concurrent requests
 */
declare class RequestQueue<Res, Err> {
    private queue;
    private responses;
    private currentRequestCount;
    /**
     * Once you reach max request count,
     * it will send no more requests
     */
    private maxRequestCount;
    private maxConcurrentRequest;
    private eventEmitter;
    private lastRequestTimeoutMs;
    private intervalId;
    private hasNoMoreRequestEnqueued;
    private externalSuccessfulRequestCount;
    private totalSuccessfulRequestCount;
    private logger;
    constructor({ maxConcurrentRequest, maxRequestCount, lastRequestTimeoutMs, logger, }: {
        maxConcurrentRequest: number;
        /**
         * default: 15000 ms
         */
        lastRequestTimeoutMs?: number;
        maxRequestCount?: number;
        logger: ReturnType<typeof createLogger>;
    });
    private terminate;
    private terminateIfPossible;
    /**
     * This function is used to periodically check the number of concurrent
     * requests at a time and send the request if the number of concurrent requests
     * is less than `maxConcurrentRequest`.
     *
     * If there are no more requests to send, it will emit `complete` event and terminate.
     */
    private checkAndSendRequest;
    private sendRequest;
    /**
     * Let RequestQueue know that there is going to be no more
     * request input from the user.
     *
     * This is important because RequestQueue will be able to quit
     * immediately after the last request completes knowing that
     * no more requests will be enqueued.
     */
    setNoMoreRequestEnqueued(): void;
    /**
     * User only has to enqueue his request here and RequestQueue will take
     * care of the rest.
     * @param retriveBlockRequestFn
     * any function that returns a promise (i.e. sends an async request)
     */
    enqueue(retriveBlockRequestFn: () => Promise<Res>): void;
    /**
     * @param listener any callback to be called when RequestQueue finishes its work
     * and meaning that the queue is empty
     */
    onComplete<Fn extends (...args: any[]) => void>(listener: Fn): void;
    incrementExternalRequestMatchCount(increaseBy?: number): void;
}

interface NotionContentNode {
    title: string;
    id: string;
    type: `database` | `page` | `error`;
}
/**
 * A type used to represent a single Notion 'block'
 * or 'node' as we'd like to call it in this graph-related project
 */
declare type NotionContentNodeUnofficialAPI = {
    title: string;
    id: string;
    /**
     * Notion workspace id
     */
    spaceId: string;
    /**
     * parent node's id
     */
    parentId: NotionContentNodeUnofficialAPI[`id`];
    /**
     * children count
     */
    cc?: number;
    type: `page` | `collection_view` | `alias`;
} | {
    title: string;
    /**
     *  collection view page id
     *  */
    id: string;
    /**
     * Notion workspace id
     */
    spaceId: string;
    /**
     * children count
     */
    cc?: number;
    parentId: NotionContentNodeUnofficialAPI[`id`];
    type: `collection_view_page`;
    /**
     * collection id
     * */
    collection_id: string;
};

declare type DeepReadonly<T> = T extends (infer R)[] ? DeepReadonlyArray<R> : T extends Function ? T : T extends object ? DeepReadonlyObject<T> : T;
declare type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>;
declare type DeepReadonlyObject<T> = {
    readonly [P in keyof T]: DeepReadonly<T[P]>;
};

/**
 * represents the graph of nodes.
 *
 * example:
 * ```
 * {
 *  [node_id0]: {
 *    [node_id1]: true,
 *    [node_id2]: true,
 *  },
 *  [node_id1]: {
 *    [node_id3]: true
 *  }
 * }
 * ```
 * this means node_id0 is connected with node_id1 and node_id2, and
 * node_id1 with node_id3. This is an undirected graph; Therfore, there
 * must not be any duplicate edge in this data structure.
 *
 * For example,
 * ```
 * {
 *  [node_id0]: {
 *    [node_id1]: true,
 *    [node_id2]: true,
 *  },
 *  [node_id1]: {
 *    [node_id0]: true
 *  }
 * }
 * ```
 * Such a graph must not be made because edge(node_id1, node_id0) exists twice.
 *
 * This kind of data structure is used in an effort to efficiently create the graph
 */
declare type RawUndirectedNodesGraph = Record<NotionContentNode[`id`], Record<NotionContentNode[`id`], boolean> | undefined>;
/**
 * d3.js uses `source: ... target: ...` format to abstract
 * the concept of an edge.
 */
interface D3JsEdge {
    source: NotionContentNode[`id`];
    target: NotionContentNode[`id`];
}
/**
 * Represents an undirected graph of nodes.
 */
declare class UndirectedNodesGraph<Node extends {
    id: NotionContentNode[`id`];
}> {
    private graph;
    private nodesLength;
    /**
     * Adds an edge between two nodes, but avoids making duplicates
     * if the edge already exists
     *
     * Existence of an edge at a time cannot guarantee the existence
     * of a vertex stored in another data structure (it depends on your implementation)
     */
    addEdgeByIds(node0id: string, node1id: string): void;
    /**
     * Adds an edge between two nodes, but avoids making duplicates
     * if the edge already exists
     *
     * usually, `target` will be stored as parent of a node
     * `source` will be the child node
     */
    addEdge(node0: Node, node1: Node): void;
    getGraph(): DeepReadonly<RawUndirectedNodesGraph>;
    /**
     * transform `this.graph` to d3.js edge (link) shape.
     * The output will be used directly in frontend.
     *
     */
    getD3JsEdgeFormat(): DeepReadonly<D3JsEdge[]>;
    get length(): number;
}

/**
 * Graph of notion blocks.
 *
 * Does a lot of async calls,
 * so it's possible that async error occurs anywhere.
 *
 * The key to handling the error is how we approach the UX in the frontend
 * regarding the error. What will we do for the user when we encounter an error?
 *
 * - Case 1: Some of the blocks are missing, but it's still viewable by the user. Then still include the errors and error messages from the server, but show the contents
 * - Case 2: All blocks are missing (ex. internet not working for some reason from the server). Then send a complete error, possibly with a helpful if message if any
 */
declare class NotionGraph {
    private unofficialNotionAPI;
    private errors;
    private nodes;
    /**
     * total number of discovered, unique nodes
     */
    private nodesLength;
    /**
     * total number of discovered, unique nodes in other spaces (= Notion workspace).
     */
    private otherSpacesNodesLength;
    /**
     * represents a graph of nodes.
     * contains info about how nodes are connected by edges
     */
    private nodesGraph;
    /**
     * @see NotionGraph['constructor']
     */
    private maxDiscoverableNodes;
    /**
     * @see NotionGraph['constructor']
     */
    private maxDiscoverableNodesInOtherSpaces;
    /**
     * @see NotionGraph['constructor']
     */
    private maxConcurrentRequest;
    private lastRequestTimeoutMs;
    private verbose;
    private logger;
    constructor({ unofficialNotionAPI, maxDiscoverableNodes, maxDiscoverableNodesInOtherSpaces, maxConcurrentRequest, lastRequestTimeoutMs, verbose, }: {
        /**
         * If you want to use your `NotionAPI` instance, you can do it yourself
         * ```ts
         * import { NotionAPI } from "notion-client"
         *
         * const notionUnofficialClient = new NotionAPI({ ...customConfig })
         * const ng = new NotionGraph({ unofficialNotionAPI: notionUnofficialClient, ... })
         * ```
         *
         * Otherwise, leave this field as undefined. This means that
         * you are only going to be able to request public pages on Notion.
         */
        unofficialNotionAPI?: NotionAPI;
        /**
         * user-defined value of maximum discoverable number of unique nodes.
         * must stop discovery once the program finds nodes over
         * the discoverable number of unique nodes set by the user.
         *
         * this is useful when your notion workspace
         * (or 'space' as it is from the actual notion API)
         * has lots of pages and you want to stop before the amount of pages you accumulate
         * becomes too many.
         *
         * setting it to null means infinity, but it's never
         * recommended because you can't guarantee how long it will take to discover
         * all nodes. Make sure you know what you are doing if you set it to `null`.
         *
         * @throws when this is smaller than maxDiscoverableNodes, which is impossible to happen
         * @default 500 nodes.
         */
        maxDiscoverableNodes?: number | null;
        /**
         * This parameter is only needed due to the existence of backlinks
         * (= 'link to page' function on Notion).
         *
         * If your page happens to have lots of backlinks to OTHER `space`s (= workspaces) out of your
         * current space, then you would need to decide if you will try to discover
         * the nodes from those spaces as well.
         *
         * Otherwise, in the worst case, the program may not halt because
         * a chain of Notion nodes that include many backlinks to other workspaces
         * will probably take hours or days to crawl all of the nodes.
         *
         * if you don't need pages or databases outside your workspace,
         * simply set this to 0.
         *
         * @throws when this is bigger than maxDiscoverableNodes, which is impossible to happen
         * @default 250 nodes
         */
        maxDiscoverableNodesInOtherSpaces?: number;
        /**
         * # network requests to be sent the same time.
         * if too big it might end up causing some delay
         * @default 35
         */
        maxConcurrentRequest?: number;
        /**
         *
         * @deprecated
         * will be removed later.
         * there is a better way to handle the last request without this.
         *
         * If `maxDiscoverableNodes` is bigger than the total pages discovered
         * and there are no more request in the duration of `lastRequestTimeoutMs`,
         * the program exits by then
         */
        lastRequestTimeoutMs?: number;
        /**
         * If set as true, will output progress as it scrapes pages
         */
        verbose?: boolean;
    });
    private accumulateError;
    /**
     * Finds the topmost block from any block id.
     * Notion API is structured in a way that any call to a getPage
     * would return its recursive parents in its response.
     * The last recursive parent will be the topmost block.
     * @param blockIdWithoutDash
     * @returns `null` if an error happens or nothing is found
     * @throws nothing
     */
    private findTopmostBlock;
    private addDiscoveredNode;
    /**
     * Notion API has a weird structure
     * where you can't get the database(=collection)'s title at once if it is a child of a page in the response.
     * You need to request the database as a parent directly again.
     * This function just uses the second response to update the database's title
     * @param page
     * @param parentNode
     * @returns nothing
     */
    private addCollectionViewTitleInNextRecursiveCall;
    /**
     * Recursively discovers notion blocks (= nodes).
     *
     * All block types we care about is `NotionContentNodeUnofficialAPI['type']`.
     * Check it out.
     */
    recursivelyDiscoverBlocks({ rootBlockSpaceId, parentNode, requestQueue, }: {
        rootBlockSpaceId: string | undefined;
        parentNode: NotionContentNodeUnofficialAPI;
        requestQueue: RequestQueue<any, Error>;
    }): Promise<void>;
    /**
     * Builds a graph from a node (also called a page or block in Notion)
     *
     * You can easily find the page's block id from the URL.
     * The sequence of last 32 characters in the URL is the block id.
     * For example:
     *
     * https://my.notion.site/My-Page-Title-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
     *
     * `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx` is the block id.
     * @param rootBlockId the block id of the page, favorably the root page in your workspace
     * so that as many pages as possible will be discovered.
     * @returns graph information relevant to frontend's graph visualization
     */
    buildGraphFromRootNode(rootBlockId: string): Promise<{
        nodes: NotionContentNodeUnofficialAPI[];
        links: ReturnType<UndirectedNodesGraph<NotionContentNodeUnofficialAPI>[`getD3JsEdgeFormat`]>;
        errors: (ErrorObject | Error)[];
    }>;
}

declare function identifyObjectTitle<Obj extends {
    object: `database` | `page` | `block`;
}>(obj: Obj): string;
/**
 *
 * @param maybe_without_dash 1429989fe8ac4effbc8f57f56486db54
 * @returns 1429989f-e8ac-4eff-bc8f-57f56486db54
 */
declare function separateIdWithDashSafe(maybe_without_dash: string): string;
declare function isIdAlreadySeparateByDash(maybe_separate_with_dash: string): boolean;
declare function nameUntitledIfEmpty(title: string): string;

declare type BlockMap = Awaited<ReturnType<NotionAPI[`getPage`]>>[`block`];
declare type Block = BlockMap[keyof BlockMap];

/**
 * Utils specific to unofficial notion api
 */
declare class UnofficialNotionAPIUtil {
    /**
     * Be as conservative as possible because
     * Notion API may change any time
     * @param page
     * @returns
     */
    static getTitleFromPageBlock(page: BlockMap[keyof BlockMap]): string;
    static getTitleFromCollectionBlock(collectionBlock: Block): string;
    /**
     * `parent_table` is space if the block is at the top level of all pages (= the block is
     * one of the pages we can click on from the left navigation panel on Notion app)
     * @param block any block (page, collection view page, ...)
     * @returns whether the block is a top level page or collection view page.
     */
    static isBlockToplevelPageOrCollectionViewPage(block: BlockMap[keyof BlockMap]): boolean;
    /**
     * Gets a notion content node from a block.
     * But the type could be anything. It's not one of the four block types we want yet.
     * @deprecated don't use this except for finding the root block
     */
    static extractTypeUnsafeNotionContentNodeFromBlock(block: BlockMap[keyof BlockMap]): null | NotionContentNodeUnofficialAPI;
}

export { NotionGraph, RawUndirectedNodesGraph, RequestQueue, UndirectedNodesGraph, UnofficialNotionAPIUtil, identifyObjectTitle, isIdAlreadySeparateByDash, nameUntitledIfEmpty, separateIdWithDashSafe };
